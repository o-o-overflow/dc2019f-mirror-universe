#!/usr/bin/env python3

FLAG_RE = r"OOO{[^}]*}"
CTF_TAG = "dc2019f"
IMAGE_FMT = CTF_TAG + "-%s"

import concurrent.futures
import contextlib
import subprocess
import tempfile
import logging
import random
import string
import json
import yaml
import time
import sys
import re
import os

logging.basicConfig()
_LOG = logging.getLogger("OOO")
_LOG.setLevel("DEBUG")

SERVICE_DIR = os.path.dirname(__file__)

SERVICE_CONF = yaml.load(open(os.path.join(SERVICE_DIR, "info.yml")))
SERVICE_NAME = SERVICE_CONF['service_name']
SERVICE_IMAGE = IMAGE_FMT % SERVICE_NAME + "-service"
INTERACTION_IMAGE = IMAGE_FMT % SERVICE_NAME + '-interaction'
LOCAL_TESTER_IMAGE = IMAGE_FMT % SERVICE_NAME + '-local-tester'

_LOG.info("USING YAML: %s/info.yml", SERVICE_DIR)
_LOG.info("SERVICE ID: %s", SERVICE_NAME)
_LOG.info("SERVICE IMAGE: %s", SERVICE_IMAGE)
_LOG.info("INTERACTION IMAGE: %s", INTERACTION_IMAGE)
_LOG.info("LOCAL TEST IMAGE: %s", LOCAL_TESTER_IMAGE)

@contextlib.contextmanager
def launch_container(image=SERVICE_IMAGE, container_id=None):
	_LOG.debug("launching container for image %s...", image)
	if container_id:
		assert os.system("docker run --name %s --rm -d -i %s" % (container_id, image)) == 0, "service container failed to start"
	else:
		container_id = subprocess.check_output("docker run --rm -d -i %s" % (image), shell=True).strip().decode('utf-8')
	_LOG.debug("container %s (image %s) launched!", container_id, image)
	time.sleep(1)

	# get endpoint info
	container_config = json.loads(subprocess.check_output("docker inspect %s" % container_id, shell=True).decode('utf-8'))
	ip_address = container_config[0]['NetworkSettings']['Networks']['bridge']['IPAddress']
	port = list(container_config[0]['Config']['ExposedPorts'].keys())[0].split("/")[0] if 'ExposedPorts' in container_config[0]['Config'] else None
	_LOG.debug("network endpoint: %s:%s", ip_address, port)

	try:
		yield container_id, ip_address, port
	finally:
		_LOG.debug("stopping container %s", container_id)
		os.system("docker kill %s 2>/dev/null >/dev/null" % container_id)
		os.system("docker rm %s 2>/dev/null >/dev/null" % container_id)

def validate_yaml():
	_LOG.info("Validating yaml...")
	assert 'service_name' in SERVICE_CONF, "no service name specified"
	assert 'initial_flag' in SERVICE_CONF, "no service flag specified"
	if 'test flag' in SERVICE_CONF['initial_flag']: _LOG.critical("REMEBER TO CHANGE THE FLAG: %s looks like the test flag", SERVICE_CONF['initial_flag'])
	if not re.match(FLAG_RE, SERVICE_CONF['initial_flag']):
		_LOG.critical("FLAG %s DOES NOT CONFORM TO THE FLAG FORMAT", SERVICE_CONF['initial_flag'])
		if not SERVICE_CONF['violates_flag_format']:
			assert False, "you violated the flag format!"

	assert (not set(SERVICE_NAME) - set(string.ascii_lowercase + '-' + string.digits)) and SERVICE_NAME[0] in string.ascii_lowercase, "SERVICE NAME MUST BE KUBERNETES-COMPATIBLE (lowercase, '-', and digits, starting with a letter)"

	assert subprocess.check_output(("git -C %s remote get-url origin"%SERVICE_DIR).split()).decode('latin1').split("/")[-1].split(".git")[0] == CTF_TAG + "-" + SERVICE_NAME, "GIT REPOSITORY MUST BE THE SAME AS THE CTF TAG PLUS THE SERVICE NAME (%s-%s)" % (CTF_TAG, SERVICE_NAME)

def build_images():
	if os.path.exists(os.path.join(SERVICE_DIR, "service", "Dockerfile")):
		_LOG.info("Building service image...")
		assert os.system("docker build -t %s %s/service" % (SERVICE_IMAGE, SERVICE_DIR)) == 0, "service docker image build failed"
	else:
		_LOG.warning("no dockerfile found for service...")

	if os.path.exists(os.path.join(SERVICE_DIR, "remote-interaction", "Dockerfile")):
		_LOG.info("Building interaction image...")
		assert os.system("docker build -t %s %s/remote-interaction" % (INTERACTION_IMAGE, SERVICE_DIR)) == 0, "interaction docker image build failed"
	else:
		_LOG.warning("no dockerfile found for remote interactions...")

	if os.path.exists(os.path.join(SERVICE_DIR, "local-tester", "Dockerfile")):
		_LOG.info("Building interaction image...")
		assert os.system("docker build -t %s --build-arg SERVICE=%s %s/local-tester" % (LOCAL_TESTER_IMAGE, SERVICE_IMAGE, SERVICE_DIR)) == 0, "local tester build failed"
	else:
		_LOG.warning("no dockerfile found for local tests...")

def test_local():
	if not os.path.exists(os.path.join(SERVICE_DIR, "local-tester", "Dockerfile")):
		return

	_LOG.info("Local-testing container...")
	with launch_container(image=LOCAL_TESTER_IMAGE) as (tester_container, _, _):
		_LOG.info("launching local tests")
		tests = SERVICE_CONF['local_tests']
		for script in tests:
			_LOG.info("launching %s", script)
			assert os.system("docker exec %s %s" % (tester_container, script)) == 0, "Check %s failed!" % script

def test_interactions():
	with launch_container() as (_, ip, port):
		run_interactions(ip, port, SERVICE_CONF['initial_flag'])

	if SERVICE_CONF['flag_path']:
		_LOG.info("testing interactions with random flag...")
		with launch_container() as (c, ip, port):
			newflag = "OOO{" + ''.join(random.choices(string.ascii_lowercase, k=16)) + "}"
			assert os.system("docker exec %s sh -c 'echo %s > %s'" % (c, newflag, SERVICE_CONF['flag_path'])) == 0
			run_interactions(ip, port, newflag)
        _LOG.warning("Adam removing short reads test.")
	#test_short_reads()

def run_interactions(ip_address, port, flag=SERVICE_CONF['initial_flag'], max_concurrency=SERVICE_CONF['concurrent_connections']):
	_LOG.info("Remote-testing container...")

	with launch_container(image=INTERACTION_IMAGE) as (interaction_container, _, _):
		def _run_interaction(script):
			_LOG.info("launching %s", script)

			try:
				output = subprocess.check_output("docker exec %s %s %s %s" % (interaction_container, script, ip_address, port), shell=True)
				if os.path.basename(script).startswith("exploit"):
					_LOG.info("... checking for the flag")
					assert flag.encode('utf-8') in output, "exploit %s did not print the flag"%script #pylint:disable=unsupported-membership-test
			except (AssertionError, subprocess.CalledProcessError):
				_LOG.error("check failed. Rerunning without stdio capture for convenience:")
				retval = os.system("docker exec %s %s %s %s" % (interaction_container, script, ip_address, port))
				_LOG.info("fyi, it returned %d that time", retval)
				raise


		_LOG.info("launching interaction scripts")
		interaction_files = SERVICE_CONF['remote_interactions']
		for f in interaction_files:
			_run_interaction(f)

		n = 2
		old_level = _LOG.level
		while n <= max_concurrency:
			_LOG.info("STRESS TESTING (%d concurrent connections)", n)
			_LOG.setLevel(max(logging.WARNING, old_level))
			with concurrent.futures.ThreadPoolExecutor(max_workers=n) as pool:
				results = pool.map(_run_interaction, (interaction_files*n)[:n])
			try:
				for _ in results:
					pass
			except Exception as e: #pylint:disable=broad-except
				_LOG.error('One iteration returns an exception: %s', str(e), exc_info=True)
				sys.exit(1)

			_LOG.setLevel(old_level)

			n *= 2

def test_short_reads():
                with launch_container() as (service_container, ip_address, port):
                        _LOG.info("SHORT-READ SANITY CHECK")
                        prev_procs = len(subprocess.check_output("docker exec %s ps aux" % service_container, shell=True).splitlines())
                        _LOG.info(f"{prev_procs} previously running")
                        assert os.system('docker run --rm ubuntu bash -ec "for i in {1..128}; do echo > /dev/tcp/%s/%s; done"' % (ip_address, port)) == 0
                        _LOG.info("waiting for service to clean up after short reads")
                        time.sleep(40)
                        num_procs = len(subprocess.check_output("docker exec %s ps aux" % service_container, shell=True).splitlines())
                        _LOG.info(f"{num_procs} now running")
                        assert prev_procs == num_procs, "your service did not clean up after short reads"

def build_bundle():
	_LOG.info("building public bundle!")

	tempdir = tempfile.mkdtemp()
	public_path = os.path.join(tempdir, SERVICE_NAME)
	os.makedirs(public_path)
	for f in SERVICE_CONF['public_files']:
		_LOG.debug("copying file %s into public files", f)
		cmd = "cp -L %s/%s %s/%s" % (SERVICE_DIR, f, public_path, os.path.basename(f))
		print(os.getcwd(), cmd)
		assert os.system(cmd) == 0, "failed to retrieve public file %s" % f

	time.sleep(2)
	assert os.system("tar cvzf %s/public_bundle.tar.gz -C %s %s" % (SERVICE_DIR, tempdir, SERVICE_NAME)) == 0, "public file tarball failed; this should not be your fault"

	print("")
	print("")
	_LOG.critical("PLEASE VERIFY THAT THIS IS CORRECT: files in public bundle:")
	os.system("tar tvzf %s/public_bundle.tar.gz" % SERVICE_DIR)

	print("")
	print("")
	print("ATTENTION: PLEASE MAKE SURE THAT THE CONTENTS OF public_files.tar.gz (SHOWN ABOVE) MAKE SENSE.")
	print("")
	print("")


if __name__ == '__main__':
	validate_yaml()
	arg = sys.argv[1] if len(sys.argv) >= 2 else ""
	if arg == 'bundle':
		build_bundle()
	elif arg == 'build':
		build_images()
		build_bundle()
	elif arg == 'test':
		if len(sys.argv) == 2:
			test_local()
			test_interactions()
		else:
			run_interactions(sys.argv[2], int(sys.argv[3]), SERVICE_CONF['initial_flag'])
	elif arg == 'launch':
		build_images()
		with launch_container(image=SERVICE_IMAGE if len(sys.argv) == 2 else sys.argv[2]) as (_, _ip_address, _port):
			print("")
			print("SERVICE RUNNING AT: %s %s" % (_ip_address, _port))
			print("nc %s %s" % (_ip_address, _port))
			print("./tester test %s %s" % (_ip_address, _port))
			print("%s:%s" % (_ip_address, _port))
			input()
	elif arg == 'deploy':
		registry = sys.argv[2]
		tagcmd = "docker tag dc2019q:%s %s:5000/dc2019q-%s:latest" % (SERVICE_NAME.lower(), registry, SERVICE_NAME.lower())
		print(tagcmd)
		assert os.system(tagcmd) == 0
		pushcmd = "docker push %s:5000/dc2019q-%s:latest" % (registry, SERVICE_NAME.lower())
		print(pushcmd)
		assert os.system(pushcmd) == 0
	else:
		build_images()
		test_local()
		test_interactions()
		build_bundle()
